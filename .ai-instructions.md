# AI Coding Instructions for Blufie Project

## Core Style Principles

### 1. NO ELSE STATEMENTS
- **Never use `else` statements** - always prefer early returns
- Replace `if (condition) { ... } else { ... }` with `if (!condition) return; ...`
- This applies to all conditional logic including error handling

### 2. MINIMIZE NESTING
- Keep nesting to an absolute minimum (max 2 levels)
- Use early returns to flatten code structure
- Extract complex logic into separate methods
- Prefer guard clauses over nested conditions

### 3. EARLY RETURNS PATTERN
```dart
// ✅ GOOD - Early return pattern
if (!isValid) return;
if (data == null) return;
if (!mounted) return;

doSomething();
```

```dart
// ❌ BAD - Nested conditions
if (isValid) {
  if (data != null) {
    if (mounted) {
      doSomething();
    }
  }
}
```

### 4. FLUTTER-SPECIFIC PATTERNS

#### Mounted Checks
```dart
// ✅ GOOD
if (!mounted) return;
setState(() { ... });

// ❌ BAD
if (mounted) {
  setState(() { ... });
}
```

#### Error Handling
```dart
// ✅ GOOD
if (result == null) {
  _showError('Operation failed');
  return;
}

_processResult(result);

// ❌ BAD
if (result != null) {
  _processResult(result);
} else {
  _showError('Operation failed');
}
```

#### Async Operations
```dart
// ✅ GOOD
Future<void> processData() async {
  if (!isValid) return;

  final data = await fetchData();
  if (data == null) {
    _handleError();
    return;
  }

  _processData(data);
}

// ❌ BAD
Future<void> processData() async {
  if (isValid) {
    final data = await fetchData();
    if (data != null) {
      _processData(data);
    } else {
      _handleError();
    }
  }
}
```

### 5. METHOD EXTRACTION RULES
- Extract complex conditions into well-named methods
- Break down large methods into smaller, focused functions
- Each method should have a single responsibility

### 6. CONDITIONAL EXPRESSIONS
- Use ternary operators for simple value assignments
- For complex logic, use early returns instead of nested ternaries

```dart
// ✅ GOOD - Simple ternary
final color = isError ? Colors.red : Colors.green;

// ✅ GOOD - Complex logic with early returns
Color getStatusColor() {
  if (isError) return Colors.red;
  if (isWarning) return Colors.orange;
  return Colors.green;
}
```

### 7. SWITCH STATEMENTS
- Prefer early returns in switch cases
- Extract complex case logic into separate methods

```dart
// ✅ GOOD
void handleAction(String action) {
  switch (action) {
    case 'save':
      _save();
      return;
    case 'cancel':
      _cancel();
      return;
    default:
      _showUnknownActionError();
      return;
  }
}
```

## Application Guidelines

1. **Always apply these rules when refactoring existing code**
2. **Write all new code following these patterns**
3. **When reviewing code, check for else statements and excessive nesting**
4. **Prioritize readability through linear code flow**

## Testing Requirements

### Unit Test Coverage Standards
- **Minimum coverage: 80%** - All new code must maintain or improve overall test coverage
- Unit tests are required for all service classes, models, and utility functions
- Critical business logic must have comprehensive test coverage
- Platform-dependent code should have proper mocking and exception handling in tests

### Coverage Guidelines
- Run `flutter test --coverage` to generate coverage reports
- Use coverage reports to identify untested code paths
- Add tests for edge cases and error conditions
- Mock external dependencies (SharedPreferences, platform channels, etc.)
- Handle platform exceptions gracefully in test environments

## Enforcement

- Use `flutter analyze` to catch basic issues
- Manual review should focus on detecting else statements and nested conditions
- Refactor any code that doesn't follow these principles immediately

---

*This file should be referenced by AI assistants to maintain consistent coding style across the project.*
